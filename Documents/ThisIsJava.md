# 목차
##### 1. [자바 시작하기](#1-자바-시작하기)
##### 2. [변수와 타입](#2-변수와-타입)
##### 3. [연산자](#3-연산자)
##### 4. [조건문과 반복문](#4-조건문과-반복문)
##### 5. [참조 타입](#5-참조-타입)
##### 6. [클래스](#6-클래스)

---

# 1. 자바 시작하기

## 1. Java의 특징
- 이식성이 높은 언어
- 객체 지향 언어
- 함수적 스타일 코딩 지원
- 메모리를 자동으로 관리(JVM)
- 다양한 어플리케이션을 개발할 수 있음
   - 개발 도구와 API를 묶어 에디션 형태로 정의하고 있음(Java SE, EE 등)
 - 동적 로딩 지원
   - 객체가 필요한 시점에 클래스를 동적으로 로딩해서 객체를 생성
   - 전체 애플리케이션을 다시 컴파일할 필요가 없음
 - 막강한 오픈소스 라이브러리가 풍부


## 2. 자바 가상기계(JVM)
- 자바 프로그램은 완전한 기계어가 아닌 중간 단계의 바이트 코드임
- 때문에 이것을 해석하고 실행할 수 있는 가상의 운영체제 필요
- 이것이 바로 JVM(가상의 운영체제 역할)
- 바이트 코드는 모든 JVM에서 동일한 실행 결과를 보장하지만 JVM은 운영체제에 종속적
- java는 JVM에 의해 기계어로 번역되고 실행됨
  - C, C++ 같은 완전한 기계어보다는 속도가 느림
  - JVM 내부의 최적화된 JIT 컴파일러를 통해서 속도의 격차는 많이 줄어드는 중

![jvm_image](./img/ThisIsJava/1_jvm.png)


## 3. 자바 프로그램 개발 순서
1. 소스 코드 작성 -> 자바 소스 파일(.java)
2. 컴파일러(javac.exe)로 컴파일 -> 바이트 코드 파일(.class)
3. JVM을 구동시키는 명령어 java.exe로 실행 -> main() 메서드를 찾아 실행

---

# 2. 변수와 타입

## 1.변수
- 변수(variable)는 **값을 저장할 수 있는 메모리의 공간을 의미**
- 프로그램에 의해서 수시로 값이 변동됨
- 한 가지 타입의 값만 저장 가능
- 의미 있는 변수 이름을 지어주는 것이 좋음
- 리터럴(literal)
  - 소스 코드 내에서 직접 입력된 값
  - 상수(contant)와 같은 의미이지만 프로그램에서는 상수를 '값을 한 번 저장하면 변경할 수 없는 변수'로 정의하기 때문에 이와 구분하기 위해 사용
- 변수는 초기화 되어야 읽을 수 있음
- 선언된 블록 내에서만 사용 가능
- 저장할 수 있는 값의 범위를 초과해서 값이 저장될 경우 엉터리 값이 변수에 저장됨 -> 쓰레기 값


## 2. 데이터 타입
### 기본(원시: primitive) 타입
- 정수, 실수, 문자, 논리 **리터럴을 직접 저장**하는 타입

#### 정수 타입(byte, char, short, int, long)
- ##### byte 타입
  - 색상 정보 및 파일 또는 이미지 등의 이진(바이너리) 데이터를 처리할 때 주로 사용됨
- ##### char 타입
  - 자바는 모든 문자를 유니코드(Unicode)로 처리함
  - Ex) char c = 65;    // 10진수
  - Ex) char c = '\u0041';  // 16진수
  - String은 기본 타입이 아닌 클래스 타입이고 String 변수는 참조 변수임
    - 문자열을 String 변수에 대입하면 문자열이 변수에 직접 저장되는 것이 아니라 String 객체가 생성되고 String 변수는 String 객체의 번지를 참고함
    - 자세한 내용은 [참조 타입]()에서 자세하게 설명
- ##### short 타입
  - C언어와의 호환을 위해 사용
  - 보통 자바에서는 잘 사용되지 않음
- ##### int 타입
  - **자바에서 정수를 연산하기 위한 기본 타입**
  - byte, short 타입의 변수와 int 타입 변수는 성능 차이가 거의 없음
    - 자바에서 정수 연산을 4 byte로 처리하기 때문
- ##### long 타입
  - 수치와 큰 데이터를 다루는 프로그램에서 사용(은행, 우주 관련 등)
  - int 타입의 저장 범위를 넘어서는 큰 정수는 반드시 소문자 'l'이나 대문자 'L'을 붙어야 함
    - 그렇지 않으면 컴파일 에러 발생
    - 보통 혼동을 피하기 위해 대문자 'L'을 사용함
    - Ex) long var = 1000000000L;

#### 실수 타입(float, double)
- 실수는 정수와 달리 부동소수점(floating-point) 방식으로 저장됨
- 높은 정밀도를 요구하는 계산에서는 double 타입을 사용
- 자바는 실수 리터럴의 기본 타입을 double로 간주함
- 실수 리터럴을 float 타입 변수에 저장하려면 리터럴 뒤에 소문자 'f'나 대문자 'F'를 붙여야 함

#### 논리 타입(boolean)
- 1byte(8bit)로 표현되는 논리값(true/false)을 저장할 수 있는 데이터 타입
- 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는데 주로 이용됨


## 3. 타입 변환
- 데이터 타입을 다른 데이터 타입으로 변환하는 것
- 자동(묵시적) 타입 변환과 강제(명시적) 타입 변환이 있음

#### 자동 타입 변환(Promotion)
- 프로그램 실행 도중 자동적으로 타입 변환이 일어남
- 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생
- 변환 이전의 값과 변환 이후의 값은 동일함 -> 손실 없이 그대로 보존

#### 강제 타입 변환(Casting)
- 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장
- float -> int 형변환의 경우 소수점 이하 부분은 버려지고 정수 부분만 저장됨
- 사용자로부터 입력받은 값을 변환할 때 손실이 발생하지 않도록 해야함
- 정수 타입을 실수 타입으로 변환할 때 정밀도 손실을 피해야 함
  - 모든 int 값을 실수 타입으로 안전하게 변환시키는 double 타입을 사용하면 됨
  - double의 가수부는 52비트가 할당되어 있기 때문에 모든 int 값 커버 가능

#### 연산식에서의 자동 타입 변환
- 연산은 기본적으로 같은 타입의 피연산자(operand) 간에만 수행됨
- 정수 연산일 경우 int 타입을 기본으로 함
  - 크기가 4byte 보다 작은 타입(byte, char, short)은 4byte인 int 타입으로 변환된 후 연산이 수행됨
  - 따라서 연산 결과도 int 타입임
- 피연산자 중 하나가 long 타입이라면 다른 피연산자도 long 타입으로 변환 -> 결과값도 long 타입
- 실수 연산은 double 타입을 기본으로 함

---

# 3. 연산자

## 1. 연산자와 연산식
- 연산(operations) : 데이터를 처리하여 결과를 산출하는 것
- 연산자(operator) : 연산에 사용되는 표시나 기호
- 피연산자(operand) : 연산되는 데이터
- 연산식(expressions) : 연산의 과정을 기술한 것
- 산출되는 값의 타입은 연산자별로 다름
- 필요로 하는 피연산자의 수에 따라 단항, 이항, 삼항 연산자로 구분함


## 2. 단항 연산자
#### 비트 반전 연산자(~)
- 비트 반전 연산자 산출 타입은 int 타입임
- 부호를 바꾸기 위해서는 비트 반전 연산자를 사용한 후 +1을 해줘야 함
```java
byte v1 = 10;
int v2 = ~v1 + 1;
```


## 3. 이항 연산자

#### 산술 연산자(+, -, *, /, %)
- boolean 타입을 제외한 모든 기본 타입에 사용 가능
- 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용함
  - 피연산자들이 *모두 정수 타입이고, int 타입(4 byte)보다 작은 타입일 경우* 모두 int 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 **산출 타입은 int**이다.
  - 피연산자들이 *모두 정수 타입이고, long 타입이 있을 경우* 모두 long 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 **산출 타입은 long**이다.
  - 피연산자 중 *실수 타입(float, double)이 있을 경우*, 크기가 큰 실수 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 **산출 타입은 실수 타입**이다.
- 정수 타입 연산의 결과가 int 타입으로 나오는 이유 -> JVM이 기본적으로 32비트 단위로 계산하기 때문
- 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산됨
```java
char c1 = 'A' + 1;  // 오류 발생 안함
char c2 = 'A'
char c3 = c2 + 1;   // 컴파일 에러
char c4 = (char) (c2 + 1);  // 강제 타입 변환(casting)을 했기 때문에 정상 동작
```

- ##### 오버플로우 탐지
  - 산술 연산할 때 산출 타입으로 충분히 표현 가능한지 살펴봐야 함
  - safeAdd() 메소드를 사용하면 오버플로우 발생 시 ArithmeticException을 발생시켜 데이터에 쓰레기값이 들어가는 것을 방지할 수 있음
- ##### 정확한 계산은 정수 사용
  - 이진 포맷의 가수를 사용하는 부동소수점 타입(float, double)은 0.1을 정확히 표현할 수 없어 근사치로 처리함
  - 정확한 계산이 필요하다면 정수 연산으로 변경해서 계산해야 함
- ##### NaN과 Infinity 연산
  - 정수 연산 시 우측 피연산자로 0을 사용하면 실행 시 ArithmeticExceiption 발생
  - 실수 연산으로 하게 되면 에러는 발생하지 않지만 Infinity 값을 가지고 % 연산은 NaN(Not a Number)을 가짐
  - Inifinity와 NaN은 어떤 다른 값과 연산을 하더라도 Inifinity와 NaN이 산출되기 때문에 데이터가 엉망이 될 수 있음
    - 이를 방지하기 위해 Double.isInfinity()와 Double.isNaN() 메소드를 사용함

#### 문자열 연결 연산자
- 문자열을 서로 결합하는 연산자
- 문자열과 숫자가 혼합된 + 연산식은 왼쪽에서부터 오른쪽으로 연산이 진행됨
```java
"JDK" + 3 + 3.0;        // "JDK33.0"
3 + 3.0 + "JDK";        // "6.0JDK"
```

#### 비교 연산자
- 흐름 제어문에서 주로 이용되어 실행 흐름을 제어할 때 사용됨
- 연산을 수행하기 전에 타입 변환을 통해 피연산자의 타입을 일치시킴(자동 타입 변환 적용)
```java
'A' == 65       // true, 'A'가 더 큰 타입인 int 타입으로 변환되어 65 == 65로 수행
3 == 3.0        // true, double이 int보다 더 큰 타입이기 때문에 3.0 == 3.0으로 비교

/* 예외사항 */
0.1 == 0.1f     // false
/*
이진 포맷의 가수를 사용하는 모든 부동소수점 타입은 0.1을 정확히 표현할 수 없어서 
0.1f는 0.1의 근사값으로 표현되어 0.1000000149011612와 같은 값이 됨

때문에 피연산자라를 모두 float 타입으로 강제 타입 변환한 후에 비교 연산을 하던지,
정수로 변환해서 비교해야 함
*/
```

#### 논리 연산자
- 논리 연산자의 피연산자는 boolean 타입만 사용 가능
- &&와 &는 산출 결과는 같지만 연산 과정이 조금 다름
  - &&는 앞의 피연산자가 false라면 바로 false 산출 결과를 내지만 &는 두 피연산자 모두를 평가해서 산출 결과를 냄
  - 따라서 보다 &&가 더 효율적으로 동작함
  - 이는 ||와 |도 마찬가지

#### 비트 연산자
- 0과 1로 표현이 가능한 정수 타입만 비트 연산 가능

--- 

# 4. 조건문과 반복문


#### if문
- 조건식에 true 또는 false 값을 산출할 수 있는 연산식이나, boolean 변수가 올 수 있음
#### switch문
- 조건식에 정수형(byte, char, short, int)이 올 수 있음
- 조건식에 boolean, 실수형(float, double)은 사용불가
- break를 써주지 않으면 case 값과 상관없이 다음 case가 연달아 실행됨

#### for문
- 반복 횟수를 알고 있을 때 주로 사용함
- 초기화식에서 루프 카운트 변수를 선언할 때 부동소수점 타입을 사용하지 말아야 함
  - 근사값으로 표현되기 때문에 원하는만큼 루프가 시행되지 않을 수 있음

#### while문
- 조건에 따라 반복할 때 주로 사용
- 조건식이 false가 되면 반복 행위를 멈추고, while문을 종료함

#### break, continue
- 반복문이 중첩되있을 때 label을 사용하여 바깥쪽 반복문까지 종료하거나 다음 루프를 실행할 수 있음
```java
for (;;) {
    for (;;) {
        break;      // 안쪽 반복문만 종료
    }
}

Outer: for (;;) {
    for (;;) {
        break Outer;      // 라벨이 적혀있는 바깥쪽 반복문까지 종료
    }
}

All: for (;;) {
    for (;;) {
        for (;;) {
            continue All;      // continue도 마찬가지
        }
    }
}
```

---

# 5. 참조 타입

## 1. 데이터 타입 분류
- 자바의 데이터 타입
  - 기본 타입(primitive type) : 정수, 실수, 문자, 논리 리터럴을 저장하는 타입
  - 참조 타입(reference type) : 객체(Object)의 번지를 참조하는 타입(배열, 열거, 클래스, 인터페이스 등)


## 2. 메모리 사용 영역
- JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 다음과 같이 세부영역으로 구분해서 사용함
- 추후 다시 읽어봐야 할 글
  - [Full explanation of JVM – Runtime Data Area and How JVM using it](https://blog.knoldus.com/full-explanation-of-jvm-runtime-data-area-and-how-jvm-using-it/)
  - [자바 메모리 구조(Runtime Data Area)](https://jithub.tistory.com/40)

![runtime data area](./img/ThisIsJava/5_runtime_data_area.png)

### 메소드 영역
- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 runtime contant pool, field data, method data, method 코드, constructor 코드 등을 분류해서 저장함
- Class Loader가 적재한 클래스(또는 인터페이스)에 대한 메타데이터 정보가 저장됨
- JVM이 시작할 때 생성되고 **모든 스레드가 공유**하는 영역

### 힙(Heap) 영역
- 객체와 배열이 **동적**으로 생성되는 영역
  - 이를 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조함
- 참조하는 변수나 필드가 없다면 의미 없는 객체(쓰레기)로 취급하고 JVM의 GC(Garbage Collector)를 실행시켜 쓰레기 객체를 힙 영역에서 자동으로 제거함
- 개발자는 객체 제거를 위해 별도의 코드를 작성할 필요가 없고 오히려 부작용만 낳을 가능성이 큼
- 모든 Thread가 공유하기 때문에 동기화 문제가 발생할 수 있음

### JVM 스택(Stack) 영역
- 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당됨
- 기본적으로 main 스레드 하나만 존재하며 JVM 스택도 하나임
- 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)함
- printStackTrace()에서 Stack Trace의 각 라인은 하나의 프레임을 표현함
- 로컬 변수 스택
  - 프레임 내부에 있음
  - 초기화될 때 변수가 이 영역에 생성됨
  - 변수는 선언된 블록 안에서만 스택이 존재하고 블록을 벗어나면 스택에서 제거됨


## 3. 참조 변수의 ==, != 연산
- 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용됨
- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소 값을 비교한느 것임


## 4. null과 NullPointerException
- 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있음
- null로 초기화된 참조 변수는 스택 영역에 저장됨
- NullPointerException : 참조 타입 변수를 잘못 사용하면 발생함


## 5. String 타입
- 큰 따옴표로 감싼 문자열 리터럴을 대입하여 저장 가능
```java
String s;
s = "test";
String s2 = "second";
```
- new 연산자
  - 힙 영역에 새로운 객체를 만들 때 사용
  - 객체 생성 연산자라고도 함
```java
String s1 = "TEST";
String s2 = "TEST";
/* 
s1 == s2 -> true
s1.equals(s2) -> true

자바에서는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어있음
*/ 

String s3 = new String("TEST");
String s4 = new String("TEST");
/*
s3 == s4 -> false
s3.equals(s4) -> true

문자열이 동일하더라도 new를 사용하여 String 객체를 생성했기 때문에 서로 다른 객체를 참조함
문자열의 값은 같기 때문에 equals() 메소드의 결과값은 true임
*/
```


## 6. 배열 타입
- 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해놓은 자료구조임
- 같은 타입의 데이터만 저장할 수 있음
- 선언과 동시에 저장할 수 있는 데이터 타입이 결정됨
- 다른 데이터 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch) 컴파일 오류 발생

### 배열 선언
- 대괄호 []를 타입 또는 변수 뒤에 붙임
- null 값으로 초기화할 수 있음
- 배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않음
  - new 연산자를 사용해서 할당해주는건 가능
- new 연산자를 사용하여 배열을 생성할 경우, 배열은 자동적으로 기본값으로 초기화됨
  - 배열의 데이터 타입에 따라 0, 0.0f, false, null 등으로 초기화됨
```java
// 배열 선언
int[] intArray;
double[] doubleArray;
String[] strArray;

int intArray[];
double doubleArray[];
String strArray[];

// 배열 생성
String[] names = {"Alice", "Brown", "Charile"};

String[] names = null;
names = {"Alice", "Brown", "Charile"};                  // 컴파일 에러 발생!!
naems = new String[] {"Alice", "Brown", "Charile"};     // 정상 동작

int[] scores = new int[3];    // 기본값인 0으로 초기화
// 배열 생성 후 값을 저장하기 위해서 대입 연산자 사용
scores[0] = 84;
scores[1] = 91;
scores[2] = 76;
```
- 배열 길이
  - length 필드 사용
  - length 필드는 읽기 전용이기 때문에 바꿀 수 없음
  - for문에서 유용하게 사용
- #### 다차원 배열
  - 값들이 행과 열로서 구성된 배열을 2차원 배열이라고 함
![2d_array](./img/ThisIsJava/5_2d_array.png)
  - 배열 변수인 arr2는 길이가 2인 배열을 참조함(0x10)
  - arr2[0]은 arr2[0][0]을 참조함
  - arr2[1]은 arr2[1][0]을 참조함
- #### 배열 복사
  - 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없음
  - 만약 길이를 변경하고 싶다면 새로운 배열을 생성하고, 기존 배열 항목을 복사해야 됨
  - 얕은 복사(shallow copy)
    - 새 배열에 이전 배열의 객체 주소를 복사
    - 기존 배열의 값을 수정하면 새 배열에도 영향을 끼침
  - 깊은 복사(deep copy)
    - 참조하는 객체를 별도로 생성
  - [자바 배열 복사 메소드 참고](https://coding-factory.tistory.com/548)
- #### 향상된 for문
```java
int[] scores = {95, 71, 84, 93, 87};

for (int score: scores) {
    // do something
}
```

## 7. 열거 타입(enumeration type)
- 한정된 값만을 가지는 데이터 타입
- 몇 개의 열거 상수(enumeration constant) 중에서 하나의 상수를 저장하는 데이터 타입
- 네이밍
  - 열거 타입 이름은 관례적으로 pascal case를 사용함
  - 열거 타입 이름과 소스 파일명은 대소문자 모두 동일해야함
  - 관례적으로 열거 상수는 모두 대문자로 작성하고, 여러 단어일 경우 단어 사이를 언더바(_)로 연결함
```java
// Week.java

public enum Week {      // Week -> 열거 타입 이름
    /* 열거 상수 */
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```

```java
// test.java

/* 
- 열거 타입 변수 today에 열거 상수 대입
- 열거 상수는 단독으로 사용 못하고 열거타입.열거상수로 사용 가능
- 열거 상수는 열거 객체로 생성되기 때문에 Heap 영역에 있음

- 여기서는 열거 타입 Week가 총 7개의 Week 객체로 생성되고, 
  메소드 영역에 생성된 열거 상수가 Week 객체를 각각 참조함
- 열거 타입 변수 today는 stack 영역에 생성됨
*/
Week today = Week.SUNDAY;       

today == Week.SUNDAY;       // true, 동일한 Week 객체를 참조하기 때문

```

--- 

# 6. 클래스

## 1. 객체 지향 프로그래밍
- 객체 지향 프로그래밍(OOP: Object Oriented Programming)

### 1) 객체
- 객체(Object) : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중 **자신의 속성을 가지고 있고 다른 것과 식별 가능한 것**
- 객체 모델링(Object Modeling)
  - 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
  - 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정

### 2) 객체의 상호작용
- 객체들은 각각 독립적으로 존재
- 다른 객체와 서로 상호작용
- 상호작용 수단은 메소드임
- 매개값 : 메소드를 실행하기 위해 필요한 데이터

### 3) 객체 간의 관계
- 사용 관계, 상속 관계, 집합 관계 등이 있음

### 4) 객체 지향 프로그래밍의 특징

#### 캡슐화(Encapsulation)
- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
- 외부 개겣는 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용 가능
- 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 함
- 접근 제한자(Access Modifier) : 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호하기 위해 사용

#### 상속(Inheritance)
- 필드와 메소드를 하위 객체에게 물려줌
- 반복된 코드의 중복을 줄여주고 개발 시간을 절약, 유지 보수 시간을 최소화 시켜줌

#### 다형성(Polymorphism)
- 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질
- 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해줌
- 다형성을 통해 객체의 부품화 가능


## 2. 객체와 클래스
- 클래스(Class) : 객체를 생성하기 위한 필드와 메소드가 정의되어 있음
- 인스턴스(Instance) : 클래스로부터 만들어진 객체
- 클래스로부터 객체를 만드는 과정 -> 인스턴스화
- 객체 지향 프로그래밍 개발의 세 가지 단계
  - 클래스 설계
  - 설계된 클래스를 가지고 사용할 객체 생성
  - 생성된 객체를 이용


## 3. 클래스 선언
- 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있음
- 가급적이면 소스 파일 하나당동일한 이름의 클래스 하나만을 선언하는 것이 좋음


## 4. 객체 생성과 클래스 변수
- new 연산자
  - 클래스로부터 객체를 생성시키는 연산자
  - new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있음
  - new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생서됨
  - 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴함
- 클래스의 용도
  - 라이브러리(API: Application Program Interface)용 : 다른 클래스에서 이용할 목적으로 설계됨
  - 실행용 : 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할


## 5. 클래스의 구성 멤버
- 필드(Field), 생성자(Constructor), 메소드(Method)가 있음
- 생략되거나 복수 개가 작성될 수 있음

### 1) 필드
- 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
- 생성자와 메소드 전체에서 사용됨
- 객체가 소멸되지 않는 한 객체와 함께 존재함

### 2) 생성자
- new 연산자로 호출되는 특별한 중괄호 {} 블록
- 객체 생성 시 초기화를 담당함
- 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 함
- 클래스 이름으로 되어 있고 리턴 타입이 없음

### 3) 메소드
- 객체의 동작에 해당함
- 필드 읽기/수정, 다른 객체를 생성해서 다양한 기능 수행
- 객체 간의 데이터 전달의 수단으로 사용됨
- 외부로부터 매개값을 받을 수 있고, 실행 후 어떤 값을 리턴할 수 있음


## 6. 필드(Field)
- 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장
- 클래스 멤버 변수라고도 함

#### 필드 선언
- 클래스 중괄호 {} 블록 어디서든 존재할 수 있음(생성자와 메소드 내부 제외)
- 생성자와 메소드 중괄호 블록 내부에 선언된 것 -> 로컬 변수
- 초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정됨

#### 필드 사용
- 필드를 사용하기 위해서는 먼저 객체를 생성해야 함 
  -> 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재 X
- 도트(.) 연산자 : 객체 접근 연산자, 객체가 가지고 있는 필드나 메소드를 사용할 때 쓰임


## 7. 생성자(Constructor)
- new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당함
- 객체 초기화 : 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것
- 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없음
- 생성자에서 예외(에러)가 발생했다면 객체는 생성되지 않음
- 반드시 존재하며, 하나 이상을 가질 수 있음
  
#### 생성자 오버로딩(Overloading)
- 매개 변수를 달리하는 생성자를 여러개 선언하는 것

#### 다른 생성자 호출(this())
- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있음
- 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선 가능
- this()
  - 자신의 다른 생성자를 호출하는 코드
  - 반드시 **생성자의 첫줄**에서만 허용됨
  - this() 다음에는 추가적인 실행문들이 올 수 있음
```java
public class Car {
  String model;
  String color;
  int maxSpeed;

  //생성자
  Car() {

  }

  // 다른 생성자를 호출함으로써 중복 코드를 최소화 함
  Car(String model) {
    this(model, "은색", 250);
  }

  Car(String model, String color) {
    this(model, color, 250);
  }

  Car(String model, String color, int maxSpeed) {
    // 공통 실행 코드
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
  }
}
```


## 8. 메소드
- 객체의 동작에 해당하는 중괄호 {} 블록
- 객체 간의 데이터 전달 수단으로 사용됨
- 외부로부터 매개값을 받을 수 있고, 실행 후 어떤 값을 리턴할 수 있음

### 1) 메소드 선언
- 선언부(리턴타입, 메소드 이름, 매개변수 선언)와 실행 블록으로 구성됨
- 메소드 선언부를 메소드 시그니처(signature)라고도 함

#### 리턴 타입
- 메소드가 실행 후 리턴하는 값의 타입

#### 매개 변수 선언
- 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용됨

#### 매개 변수의 수를 모를 경우
- 매개 변수를 배열 타입으로 선언하여 해결할 수 있음
  - 메소드를 호출하기 전에 배열을 생성해야 함
- 키워드 ... 로 가변인자(variable argument) 사용 가능
  - 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용됨
```java
void sum(int ... values) {
  // do something
}

sum(1, 2, 3);
sum(1, 2, 3, 4, 5)

int[] values = { 1, 2, 3 };
sum(values);
sum(new int[] { 1, 2, 3, 4, 5})
```

### 2) 리턴(return)문

#### 리턴값이 있는 메소드
- 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 함
- 만약 return문이 없다면 컴파일 오류 발생
- return문이 실행되면 메소드는 즉시 종료됨
- 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 함

#### 리턴값이 없는 메소드(void)
- return문을 사용하면 메소드 실행을 강제 종료시킴

### 3) 메소드 오버로딩
- 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
- 매개 변수의 타입 ,개수, 순서 중 하나가 달라야 함
- 오버로딩된 메소드를 호출할 때 JVM은 매개값의 타입을 보고 메소드를 선택함
```java
int plus(int x, int y) {
  int result = x + y;
  return result;
}

double plus(double x, double y) {
  double result = x + y;
  return result;
}

plus(10, 20);         // int plus(int x, int y) 호출
plus(10.5, 25.3);     // double plus(double x, double y) 호출

int x = 10;
double y = 20.3;
plus(x, y);           // double plus(double x, double y) 호출
/* 
JVM에서는 일차적으로 매개 변수 타입을 보지만, 
매개 변수의 타입이 일치하지 않을 경우, 자동 타입 변환이 가능한지를 검사함

첫 번째 매개 변수인 int 타입은 dobule 타입으로 변환이 가능함
-> double plus(double x, double y) 호출
*/
```
```java
int divide(int x, int y) {}
double divide(int a, int b) {}
/*
컴파일 오류 발생!
리턴 타입만 다르고 매개 변수가 동일하기 때문에 메소드 오버로딩이 아님
JVM에서 적절한 메소드를 선택할 때 리턴 타입은 아무런 영향을 끼치지 못하기 때문
*/
```


## 9. 인스턴스 멤버와 this
- 인스턴스(instacne) 멤버 : 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드


## 10. 정적 멤버와 static
- 정적(static) 멤버
  - 클래스에 고정된 멤버
  - 객체를 생성하지 않고 사용할 수 있는 필드와 메소드
  - 클래스 멤버라고도 함
- 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됨
  - 때문에 클래스의 로딩이 끝나면 바로 사용할 수 있음
- 인스턴스/정적 필드와 메소드 판단기준
  - 인스턴스 필드/메소드
    - 객체마다 가지고 있어야 할 데이터
    - 인스턴스 필드을 이용해서 실행해야 함
  - 정적 필드/메소드
    - 객체마다 가지고 있을 필요성이 없는 공용적인 데이터
    - 인스턴스 필드를 이용하지 않음
```java
public class Calculator {
  String color;                       // 인스턴스 필드
  static double pi = 3.141592;        // 정적 필드

  void setColor(String color) {       // 인스턴스 메소드
    this.color = color;
  }
  static int plus(int x, int y) {     // 정적 메소드
    return x + y;
  }
  static int minus(int x, int y) {    // 정적 메소드
    return x - y;
  }
}
```

#### 정적 초기화 블록
- 정적 필드는 일반적으로 필드 선언과 동시에 초기값을 줌
- 생성자는 객체 생성 시에만 실행됨 -> 정적 필드는 생성자에서는 초기화 작업을 할 수 없음
- 정적 블록(static block)
  - 정적 필드의 복잡한 초기화 작업을 위해 사용
  - 클래스가 메모리로 로딩될 때 자동적으로 실행되고, 여러 개 있다면 선언된 순서대로 실행됨
```java
public class Television {
  static String company = "Samsung";
  static String model = "LCD";
  static String info;

  static {
    info = company + "-" + model;
  }
}
```

- 정적 메소드와 블록 내부에서는 인스턴스 필드나 메소드를 사용할 수 없음
  - this 키워드도 사용 불가
  - 객체를 먼저 생성하고 참조 변수로 접근해야 함
```java
public class ClassName {
  int field1;
  static int field2;

  void method1() {}
  static void method2() {}

  static {
    field1 = 10;        // 컴파일 에러
    method1()           // 컴파일 에러
    field2 = 10;
    method2();
  }
  static void method3() {
    this.field1 = 10;   // 컴파일 에러
    this.method1();     // 컴파일 에러
    field2 = 10;
    method2();
  }

}
```

#### 싱글톤(Singleton)
- 단 하나의 객체만 만들도록 보장해야할 때 사용
- 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 함
  - 생성자를 호출한 만큼 객체가 생성되기 때문
  - 생성자 앞에 private 접근 제한자를 붙여줌
- 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화함
- 정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 함
- 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 잣니의 객체를 리턴해줌

```java
public class SingletonClass {
  // 정적 필드
  private static SingletonClass singleton = new SingletonClass();

  // 생성자
  private SingletonClass() {}

  // 정적 메소드
  static SingletonClass getInstance() {
    return singleton;
  }
```

```java
SingletonClass c1 = SingletonClass.getInstance();
SingletonClass c2 = SingletonClass.getInstance();
```


## 11. final 필드와 상수

### 1) final 필드
- 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정될 수 없음
- 초기값 설정
  - 필드 선언 시 초기화
  - 생성자에서 초기화
  - 생성자에서도 final 필드를 초기화해주지 않으면 컴파일 에러 발생
- 객체마다 저장됨

### 2) 상수(static final)
- 객체마다 저장되지 않고, 클래스에만 포함됨
- 한 번 초기값이 저장되면 변경할 수 없음
- 복잡한 초기화의 경우 정적 블록에서도 할 수 있음
- 상수명은 모두 대문자로 작성해주는 것이 관례이며, 언더바(__)로 단어들을 연결해줌


## 12. 패키지(Package)
- 클래스를 체계적으로 관리하기 위해 사용
- 물리적인 형태는 파일 시스템의 폴더임
- 클래스를 유일하게 만들어주는 식별자 역할을 함
  - 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식함
- 클래스의 전체 이름은 "패키지명 + 클래스명"임(상위패키지.하위패키지.클래스)

### 1) 패키지 선언
- 컴파일러는 클래스에 포함되어 있는 패키지 선언을 보고, 파일 시스템의 폴더로 자동 생성시킴
- 여러 회사에서 참여하거나 다른 회사의 패키지를 이용하여 소프트웨어를 개발할 경우
  - 패키지가 서로 중복되지 않도록 회사의 도메인 이름으로 패키지를 만듬
  - 도메인은 등록 기관에서 유일한 이름이 되도록 검증되었기 때문
  - 도메인 이름 역순으로 패키지 이름을 지어줌 -> 포괄적인 이름이 상위 패키지가 되도록 하기 위해
- 마지막에 프로젝트 이름을 붙여주는 것이 관례임
```
com.samsung.projectname
com.hyundai.projectname
com.lg.projectname
com.apache.projectname
```

### 2) import문
- 다른 패키지에 속하는 클래스를 사용하기 위해 사용
  - import를 사용하지 않으면 클래스 사용 시 패키지 이름을 모두 기술해야 함
- 사용하고자 하는 패키지를 import문으로 선언하고, 클래스를 사용할 때에는 패키지를 생략함
- import문이 작성되는 위치는 패키지 선언과 클래스 선언 사이임
- import문으로 지정된 패키지의 하위 패키지는 import 대상이 아님


## 13. 접근 제한자(Access Modifier)
- 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 필드, 생성자, 메소드를 설계하는 것이 바람직함 -> 이러한 기능을 구현하기 위해 접근 제한자 사용

![access_modifier](./img/ThisIsJava/6_access_modifier.jpg)

### 1) 클래스의 접근 제한

#### default 접근 제한
- 클래스 선언 시 public을 생략했다면 기보적으로 default 접근 제한을 가짐
- 같은 패키지에서 아무런 제한 없이 사용 가능
- 다른 패키지에서는 제한됨

#### public 접근 제한
- 다른 패키지에서도 아무런 제한 없이 사용 가능
- 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발한다면 반드시 public 접근 제한 사용해야 함

### 2) 생성자의 접근 제한
- 자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일함

### 3) 필드와 메소드의 접근 제한
- 클래스 내부에서만 사용할 것인지, 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 함


## 14. Getter와 Setter 메소드
- OOP에서는 메소드를 통해서 데이터를 변경하는 방법을 선호함
- 데이터는 욉우세ㅓ 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도함
- 메소드에서 매개값을 검증해서 유요한 값만 데이터에 저장하기 위함


## 15. 어노테이션(Annotation)
- 어노테이션은 메타데이터(metadata)라고 볼 수 있음
- **메타데이터(metadata)** : 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보임
- 용도
  - 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
  - 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
  - 실행 시 (런타임 시) 특정 기능을 실행하도록 정보를 제공
- 대표적으로 @Override 어노테이션이 있으며, 메소드가 오버라이드(재정의)된 것임을 컴파일러에게 알려주어 컴파일러가 오버라이드 검사를 하도록 함
- 실행 시 클래스의 역할을 정의하기도 함

### 1) 어노테이션 타입 정의와 적용
- 어노테이션은 엘리먼트(element)를 멤버로 가질 수 있음
  - 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있음
  - 엘리먼트 타입으로는 기본 데이터 타입, 참조 데이터 타입, Class 타입 등을 사용 가능
  - 디폴트 값이 없을 경우 적용 시 반드시 값을 기술해줘야 함
- 기본 엘리먼트인 value를 가질 수 있음
```java
// 정의
public @interface AnnotationName {
  String value();
  String elementName1();
  int elementName2() default 5;
}

// 사용
@AnnotationName(elementName1="값", elementname2=3);
@AnnotationName(elementName1="값");
@AnnotationName("값");                          // 기본 엘리먼트인 value 값으로 자동 설정됨
@AnnotationName(value="값", elementname2=3);    // value와 다른 엘리먼트 값 동시에 줄 때
```

### 2) 어노테이션 적용 대상
- java.lang.annotation.ElementType 열거 상수로 정의되어 있음
- TYPE, ANNOTATION_TYPE, FIELD, CONSTRUCTOR, METHOD, LOCAL_VARIABLE, PACKAGE 등이 있음
```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
public @interface AnnotationName {

}
```

### 3) 어노테이션 유지 정책
- 사용 용도에 따라 어느 범위까지 유지할 것인지 지정해야 함
- java.lang.annotation.RententionPolicy 열거 상수로 정의되어 있음
  - SOURCE : 소스 상에서만 어노테이션 정보 유지. 소스 코드 분석 때에만 의미가 있으며 바이트 코드 파일에는 정보가 남지 않음
  - CLASS : 바이트 코드 파일까지 어노테이션 정보 유지. 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없음
  - RUNTIME : 바이트 코드 파일까지 어노테이션 정보 유지. 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있음
- #### 리플렉션(Reflection)
  - 런타임 시에 클래스의 메타 정보를 얻는 기능
  - 클래스가 가지고 있는 필드, 생성자, 메소드, 그리고 적용된 어노테이션 등을 알아낼 수 있음
  - 리플렉션을 위해서는 어노테이션 유지 정책을 RUNTIME으로 해야 함
  - 코드 자동 생성 툴을 개발하지 않는 이상 어노테이션은 대부분 런타임 시점에 사용하기 위한 용도로 만들어짐
```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationName {

}
```

---
