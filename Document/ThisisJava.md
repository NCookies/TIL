# 목차
#### 1. [자바 시작하기](#1-자바-시작하기)
#### 2. [변수와 타입](#2-변수와-타입)

---

# 1. 자바 시작하기

## 1. Java의 특징
- 이식성이 높은 언어
- 객체 지향 언어
- 함수적 스타일 코딩 지원
- 메모리를 자동으로 관리(JVM)
- 다양한 어플리케이션을 개발할 수 있음
   - 개발 도구와 API를 묶어 에디션 형태로 정의하고 있음(Java SE, EE 등)
 - 동적 로딩 지원
   - 객체가 필요한 시점에 클래스를 동적으로 로딩해서 객체를 생성
   - 전체 애플리케이션을 다시 컴파일할 필요가 없음
 - 막강한 오픈소스 라이브러리가 풍부

## 2. 자바 가상기계(JVM)
- 자바 프로그램은 완전한 기계어가 아닌 중간 단계의 바이트 코드임
- 때문에 이것을 해석하고 실행할 수 있는 가상의 운영체제 필요
- 이것이 바로 JVM(가상의 운영체제 역할)
- 바이트 코드는 모든 JVM에서 동일한 실행 결과를 보장하지만 JVM은 운영체제에 종속적
- java는 JVM에 의해 기계어로 번역되고 실행됨
  - C, C++ 같은 완전한 기계어보다는 속도가 느림
  - JVM 내부의 최적화된 JIT 컴파일러를 통해서 속도의 격차는 많이 줄어드는 중

![jvm_image](./img/ThisIsJava/1_jvm.png)

## 3. 자바 프로그램 개발 순서
1. 소스 코드 작성 -> 자바 소스 파일(.java)
2. 컴파일러(javac.exe)로 컴파일 -> 바이트 코드 파일(.class)
3. JVM을 구동시키는 명령어 java.exe로 실행 -> main() 메서드를 찾아 실행

---

# 2. 변수와 타입

## 1.변수
- 변수(variable)는 **값을 저장할 수 있는 메모리의 공간을 의미**
- 프로그램에 의해서 수시로 값이 변동됨
- 한 가지 타입의 값만 저장 가능
- 의미 있는 변수 이름을 지어주는 것이 좋음
- 리터럴(literal)
  - 소스 코드 내에서 직접 입력된 값
  - 상수(contant)와 같은 의미이지만 프로그램에서는 상수를 '값을 한 번 저장하면 변경할 수 없는 변수'로 정의하기 때문에 이와 구분하기 위해 사용
- 변수는 초기화 되어야 읽을 수 있음
- 선언된 블록 내에서만 사용 가능
- 저장할 수 있는 값의 범위를 초과해서 값이 저장될 경우 엉터리 값이 변수에 저장됨 -> 쓰레기 값

## 2. 데이터 타입
### 기본(원시: primitive) 타입
- 정수, 실수, 문자, 논리 **리터럴을 직접 저장**하는 타입

#### 정수 타입(byte, char, short, int, long)
- ##### byte 타입
  - 색상 정보 및 파일 또는 이미지 등의 이진(바이너리) 데이터를 처리할 때 주로 사용됨
- ##### char 타입
  - 자바는 모든 문자를 유니코드(Unicode)로 처리함
  - Ex) char c = 65;    // 10진수
  - Ex) char c = '\u0041';  // 16진수
  - String은 기본 타입이 아닌 클래스 타입이고 String 변수는 참조 변수임
    - 문자열을 String 변수에 대입하면 문자열이 변수에 직접 저장되는 것이 아니라 String 객체가 생성되고 String 변수는 String 객체의 번지를 참고함
    - 자세한 내용은 [참조 타입]()에서 자세하게 설명
- ##### short 타입
  - C언어와의 호환을 위해 사용
  - 보통 자바에서는 잘 사용되지 않음
- ##### int 타입
  - **자바에서 정수를 연산하기 위한 기본 타입**
  - byte, short 타입의 변수와 int 타입 변수는 성능 차이가 거의 없음
    - 자바에서 정수 연산을 4 byte로 처리하기 때문
- ##### long 타입
  - 수치와 큰 데이터를 다루는 프로그램에서 사용(은행, 우주 관련 등)
  - int 타입의 저장 범위를 넘어서는 큰 정수는 반드시 소문자 'l'이나 대문자 'L'을 붙어야 함
    - 그렇지 않으면 컴파일 에러 발생
    - 보통 혼동을 피하기 위해 대문자 'L'을 사용함
    - Ex) long var = 1000000000L;

#### 실수 타입(float, double)
- 실수는 정수와 달리 부동소수점(floating-point) 방식으로 저장됨
- 높은 정밀도를 요구하는 계산에서는 double 타입을 사용
- 자바는 실수 리터럴의 기본 타입을 double로 간주함
- 실수 리터럴을 float 타입 변수에 저장하려면 리터럴 뒤에 소문자 'f'나 대문자 'F'를 붙여야 함

#### 논리 타입(boolean)
- 1byte(8bit)로 표현되는 논리값(true/false)을 저장할 수 있는 데이터 타입
- 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는데 주로 이용됨

## 3. 타입 변환
- 데이터 타입을 다른 데이터 타입으로 변환하는 것
- 자동(묵시적) 타입 변환과 강제(명시적) 타입 변환이 있음

#### 자동 타입 변환(Promotion)
- 프로그램 실행 도중 자동적으로 타입 변환이 일어남
- 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생
- 변환 이전의 값과 변환 이후의 값은 동일함 -> 손실 없이 그대로 보존

#### 강제 타입 변환(Casting)
- 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장
- float -> int 형변환의 경우 소수점 이하 부분은 버려지고 정수 부분만 저장됨
- 사용자로부터 입력받은 값을 변환할 때 손실이 발생하지 않도록 해야함
- 정수 타입을 실수 타입으로 변환할 때 정밀도 손실을 피해야 함
  - 모든 int 값을 실수 타입으로 안전하게 변환시키는 double 타입을 사용하면 됨
  - double의 가수부는 52비트가 할당되어 있기 때문에 모든 int 값 커버 가능

#### 연산식에서의 자동 타입 변환
- 연산은 기본적으로 같은 타입의 피연산자(operand) 간에만 수행됨
- 정수 연산일 경우 int 타입을 기본으로 함
  - 크기가 4byte 보다 작은 타입(byte, char, short)은 4byte인 int 타입으로 변환된 후 연산이 수행됨
  - 따라서 연산 결과도 int 타입임
- 피연산자 중 하나가 long 타입이라면 다른 피연산자도 long 타입으로 변환 -> 결과값도 long 타입
- 실수 연산은 double 타입을 기본으로 함

---

# 3. 연산자

## 1. 연산자와 연산식
- 연산(operations) : 데이터를 처리하여 결과를 산출하는 것
- 연산자(operator) : 연산에 사용되는 표시나 기호
- 피연산자(operand) : 연산되는 데이터
- 연산식(expressions) : 연산의 과정을 기술한 것
- 산출되는 값의 타입은 연산자별로 다름
- 필요로 하는 피연산자의 수에 따라 단항, 이항, 삼항 연산자로 구분함

## 2. 단항 연산자
#### 비트 반전 연산자(~)
- 비트 반전 연산자 산출 타입은 int 타입임
- 부호를 바꾸기 위해서는 비트 반전 연산자를 사용한 후 +1을 해줘야 함
```java
byte v1 = 10;
int v2 = ~v1 + 1;
```

## 3. 이항 연산자

#### 산술 연산자(+, -, *, /, %)
- boolean 타입을 제외한 모든 기본 타입에 사용 가능
- 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용함
  - 피연산자들이 *모두 정수 타입이고, int 타입(4 byte)보다 작은 타입일 경우* 모두 int 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 **산출 타입은 int**이다.
  - 피연산자들이 *모두 정수 타입이고, long 타입이 있을 경우* 모두 long 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 **산출 타입은 long**이다.
  - 피연산자 중 *실수 타입(float, double)이 있을 경우*, 크기가 큰 실수 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 **산출 타입은 실수 타입**이다.
- 정수 타입 연산의 결과가 int 타입으로 나오는 이유 -> JVM이 기본적으로 32비트 단위로 계산하기 때문
- 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산됨
```java
char c1 = 'A' + 1;  // 오류 발생 안함
char c2 = 'A'
char c3 = c2 + 1;   // 컴파일 에러
char c4 = (char) (c2 + 1);  // 강제 타입 변환(casting)을 했기 때문에 정상 동작
```

- ##### 오버플로우 탐지
  - 산술 연산할 때 산출 타입으로 충분히 표현 가능한지 살펴봐야 함
  - safeAdd() 메소드를 사용하면 오버플로우 발생 시 ArithmeticException을 발생시켜 데이터에 쓰레기값이 들어가는 것을 방지할 수 있음
- ##### 정확한 계산은 정수 사용
  - 이진 포맷의 가수를 사용하는 부동소수점 타입(float, double)은 0.1을 정확히 표현할 수 없어 근사치로 처리함
  - 정확한 계산이 필요하다면 정수 연산으로 변경해서 계산해야 함
- ##### NaN과 Infinity 연산
  - 정수 연산 시 우측 피연산자로 0을 사용하면 실행 시 ArithmeticExceiption 발생
  - 실수 연산으로 하게 되면 에러는 발생하지 않지만 Infinity 값을 가지고 % 연산은 NaN(Not a Number)을 가짐
  - Inifinity와 NaN은 어떤 다른 값과 연산을 하더라도 Inifinity와 NaN이 산출되기 때문에 데이터가 엉망이 될 수 있음
    - 이를 방지하기 위해 Double.isInfinity()와 Double.isNaN() 메소드를 사용함

#### 문자열 연결 연산자
- 문자열을 서로 결합하는 연산자
- 문자열과 숫자가 혼합된 + 연산식은 왼쪽에서부터 오른쪽으로 연산이 진행됨
```java
"JDK" + 3 + 3.0;        // "JDK33.0"
3 + 3.0 + "JDK";        // "6.0JDK"
```

#### 비교 연산자
- 흐름 제어문에서 주로 이용되어 실행 흐름을 제어할 때 사용됨
- 연산을 수행하기 전에 타입 변환을 통해 피연산자의 타입을 일치시킴(자동 타입 변환 적용)
```java
'A' == 65       // true, 'A'가 더 큰 타입인 int 타입으로 변환되어 65 == 65로 수행
3 == 3.0        // true, double이 int보다 더 큰 타입이기 때문에 3.0 == 3.0으로 비교

/* 예외사항 */
0.1 == 0.1f     // false
/*
이진 포맷의 가수를 사용하는 모든 부동소수점 타입은 0.1을 정확히 표현할 수 없어서 
0.1f는 0.1의 근사값으로 표현되어 0.1000000149011612와 같은 값이 됨

때문에 피연산자라를 모두 float 타입으로 강제 타입 변환한 후에 비교 연산을 하던지,
정수로 변환해서 비교해야 함
*/
```

#### 논리 연산자
- 논리 연산자의 피연산자는 boolean 타입만 사용 가능
- &&와 &는 산출 결과는 같지만 연산 과정이 조금 다름
  - &&는 앞의 피연산자가 false라면 바로 false 산출 결과를 내지만 &는 두 피연산자 모두를 평가해서 산출 결과를 냄
  - 따라서 보다 &&가 더 효율적으로 동작함
  - 이는 ||와 |도 마찬가지

#### 비트 연산자
- 0과 1로 표현이 가능한 정수 타입만 비트 연산 가능