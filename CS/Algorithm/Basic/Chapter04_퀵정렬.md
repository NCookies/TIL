# 분할 정복

- `분할 정복(divide-and-conquer)`
- 문제 해결 방법 중에서 가장 유명한 재귀적 기술
- 문제를 푸는 새로운 사고 방식을 제시
- 단계
  1. 기본 단계를 해결한다. 이 부분은 가능한 한 간단한 문제이어야만 한다.
  2. 문제가 기본 단계가 될 때까지 나누거나 작게 만든다.

# 퀵 정렬

- `퀵 정렬(quick sort)`
- 정렬 알고리즘
- 선택 정렬보다 훨씬 빠르고 실제로도 자주 사용됨
- 동작
  - 배열에서 임의의 원소 하나를 고른다 => `기준 원소(pivot)`
  - 모든 원소를 기준 원소보다 작은 원소와 큰 원소로 분류함 => `분류(partitioning)`
  - 두 개의 `하위 배열(sub-array)`의 원소가 2개 이상이라면 퀵 정렬을 수행한다.

# 빅오 표기법 복습

퀵 정렬은 선택한 기준 원소에 따라 처리 속도가 달라진다는 특징이 있다. 평균적인 경우에는 $O(n\ log\ n)$이고, 최악의 경우에는 $O(n^2)$이다.

## 병합 정렬과 퀵 정렬 비교

알고리즘이 소비하는 어떤 특정한 시간을 `상수(constant)`라고 부른다. 만약 두 개의 알고리즘이 서로 다른 빅오 표기법의 시간을 가진다면 상수는 크게 문제가 되지 않기 때문에 이런 *상수들은 보통 무시*한다.

가끔은 상수 때문에 차이가 발생하기도 한다. 퀵 정렬과 병합 정렬이 그 예다. 퀵 정렬이 병합 정렬보다 더 작은 상수를 가진다. 그래서 실행 시간이 $O(n\ log\ n)$으로 동일하다면 퀵 정렬이 더 빠르다. 그리고 퀵 정렬을 사용할 때 최악의 경우보다는 일반적인 경우가 훨씬 많이 발생하기 때문에 *현실에서는 퀵 정렬이 더 빠르다.*

## 평균적인 경우와 최악의 경우 비교

퀵 정렬은 선택한 기준 원소에 크게 의존한다.

최악의 경우를 먼저 살펴보자. 만약 첫 번째 기준 원소를 리스트에서 가장 작은 수로 선택했다고 했을 때, 호출 스택은 n개가 된다. 매 스택마다 퀵 정렬 작업은 $O(n)$ 실행 시간이 걸리므로, 퀵 정렬은 최악의 경우 O(n*n) 즉, $O(n^2)$이 된다.

최선의 경우에는 호출 스택이 $log\ n$개가 된다. 따라서 실행 시간은 $O(n\ log\ n)$이다.

퀵 정렬에서는 일반적인 경우에도 최선의 경우와 같은 실행 속도를 가진다. 만약 기준 원소를 전체 배열에서 무작위로 선택한다면 퀵 정렬은 평균적으로 $O(n\ log\ n)$ 실행 시간을 가진다. 퀵 정렬은 가장 빠른 정렬 방법 중의 하나이고, 분할 정복의 좋은 예다.
