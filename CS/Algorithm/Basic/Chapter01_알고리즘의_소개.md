# 알고리즘

- 어떤 일을 하기 위한 명령의 집합
- 이미 많은 알고리즘들이 대부분의 언어로 구현되어 있다.
  - 그러나 여러 알고리즘의 차이를 이해하지 못한다면 쓸모가 없다.
  - 단순히 다른 자료구조 또는 알고리즘을 사용하는 것만으로도 성능이 크게 달라질 수 있다.

# 이진 탐색

- `탐색(search) 문제` : 방대한 데이터에서 목적에 맞는 데이터를 찾아내기 위한 알고리즘
- `이진 탐색(binary search)` : 데이터가 **정렬되어 있는 리스트**에서 특정한 값을 찾아내는 알고리즘

[binary_search.py](./code/01_binary_search.py)
```python
def binary_search(list, item):
    low = 0
    high = len(list) - 1

    while low <= high:
        mid = (low + high) // 2
        guess = list[mid]

        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        if guess < item:
            low = mid + 1

    return None

my_list = [1, 3, 5, 7, 9]               # sorted list

print(binary_search(my_list, 3))        # => 1
print(binary_search(my_list, -1))       # => None
```

- `실행 시간(running time)`
  - 시간이나 저장 공간을 절약해주는 가장 효율적인 알고리즘이 필요함
  - 단순 탐색 : 추측해야 할 최대 횟수는 리스트의 길이와 같음 => `선형 시간(linear tmie)`
  - 이진 탐색 => `로그 시간(logarithmic time)`

# 빅오 표기법

- `Big O notation`
- 알고리즘이 얼마나 빠른지 표시하는 특별한 방법
- 알고리즘이 동작하기 위해 필요한 연산 횟수

## 빅오 표기법 사용하는 이유

- 알고리즘의 실행 시간이 얼마나 걸리는지만 고려할 것이 아니라, **리스트의 크기가 증가할 때** 어떻게 증가하는지를 파악할 필요가 있기 때문
- 수행해야 할 일이 많아질 때 알고리즘에 걸리는 시간이 어떤 식으로 증가하는지를 알 수 있다.
- 이진 탐색(**O(log n)**)과 단순 탐색(**O(n)**)의 실행 시간은 같은 비율로 증가하지 않음
  - => 원소의 개수가 커질수록 이진 탐색은 단순 탐색보다 훨씬 빨라진다.

## 최악의 경우

빅오 표기법은 최악의 경우에 대한 것이다.

단순 탐색의 실행 시간은 어떤 경우에도 O(n)이다. 즉, 단순 탐색이 절대로 O(n) 시간보다 오래 걸리지 않는다는 일종의 보장이다.

## 외판원 문제

- traveling salesperson problem

```
어떤 외판원이 n개의 도시를 방문할 계획을 수립하고 있다고 가정하자. 각 도시는 다른 모든 도시와 도로로 연결되어 있다. 출장 비용을 최소로 줄이기 위하여 외판원이 거주하고 있는 도시에서 각 도시를 한 번씩만 방문하고 다시 출발한 도시로 돌아오는 가장 최소 비용의 일주여행 경로를 찾고자 한다.
```
- n개의 도시가 있다고 하면 실행 시간은 O(n!), 즉 팩토리얼 시간이다.
- 컴퓨터 과학에서 아직 풀지 못한 문제 중 하나로, 더 이상 개선시킬 수 없다고 알려져 있다.

## 정리

- 알고리즘의 속도는 시간이 아니라 **연산 횟수가 어떻게 증가하는지**로 측정한다.
  - => 입력 데이터의 크기가 늘어날 때 알고리즘의 실행 속도가 얼마나 증가하는지 알 수 있다.
- 알고리즘의 실행 시간은 `빅오 표기법`으로 나타낸다.
- O(log n)은 O(n)보다 빠르고, 찾으려는 리스트의 원소의 개수가 증가하면 상대적으로 더 빨라진다.
