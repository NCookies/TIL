# ALU와 제어장치

## ALU

![](https://velog.velcdn.com/images/ncookie/post/322f9dec-a3fe-4afe-bede-dd8c7d83e6e2/image.png)

`ALU`는 **레지스터**를 통해 `피연산자`를 받아들이고, **제어장치**로부터 수행할 연산을 알려주는 `제어 신호`를 받아들여 산술 연산, 논리 연산 등 다양한 연산을 수행한다.

ALU 연산의 `결과값`은 메모리가 아닌 **레지스터**에 우선 저장한다. CPU가 내부가 아닌 외부의 메모리에 자주 접근할 수록 프로그램의 실행 속도가 느려지기 때문이다. 

ALU는 연산 결과에 대해 추가적인 상태 정보인 `플래그(flag)`를 함께 내보낸다. 이러한 플래그는 CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 일종의 참고 정보이다. 그리고 플래그들은 **플래그 레지스터**라는 레지스터에 저장된다.

ALU가 내보내는 대표적인 플래그는 아래와 같다. `오버플로우(overflow)`는 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황을 말한다.

![](https://velog.velcdn.com/images/ncookie/post/2a288803-0a0e-4106-947a-d4f0dde2e6e6/image.png)


## 제어장치

- `제어장치`
    - 제어 신호를 내보내고, 명령어를 해석하는 부품
    - CPU의 구성 요소 중 가장 정교하게 설게된 부품이라고 해도 과언이 아니다.
- `제어 신호` : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

![](https://velog.velcdn.com/images/ncookie/post/3c4a2c21-2b2e-41c1-bb7d-4f04d603f97a/image.png)

### 제어장치가 받아들이는 정보

1. **클럭 신호**

`클럭(clock)`이란 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게 하는 시간 단위이다. 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동할 뿐 박자마다 작동하는 건 아니다.

2. **해석해야 할 명령어**

CPU가 해석해야 할 명령어는 `명령어 레지스터`라는 특별한 레지스터에 저장된다. 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.

3. **플래그 레지스터 속 플래그 값**

제어장치는 `플래그` 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.

4. 시스템 버스, 그 중에서 **제어 버스로 전달된 제어 신호**

제어장치는 제어 버스를 통해 **외부**로부터 전달된 제어 신호를 받아들이기도 한다.

### 제어장치가 내보내는 정보

크게 CPU 외부에 전달하는 제어 신호와 CPU 내부에 전달하는 제어 신호가 있다. 

CPU 외부에 제어 신호를 전달한다는 것은 곧 **제어 버스**로 제어 신호를 내보낸다는 말과 같다. 이러한 제어 신호에는 크게 메모리에 전달하는 제어 신호와 입출력장치에 전달하는 제어 신호가 있다. (여기서 입출력장치는 보조기억장치을 포함한다.)

1. CPU 외부에 전달하는 제어 신호
- 메모리
    - 메모리에 저장된 값을 읽거나 새로운 값을 쓰고 싶을 때
- 입출력장치
    - 입출력장치의 값을 읽거나 새로운 값을 쓰고 싶을 때
2. CPU 내부에 전달하는 제어 신호
- ALU
    - 수행할 연산을 지시하기 위해
- 레지스터
    - 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해

---

# 레지스터

프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다. 따라서 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악할 수 있다.

## 반드시 알아야 할 레지스터

### 프로그램 카운터

- PC; Program Counter
- 메모리에서 가져올 명령어의 주소, 즉 **메모리에서 읽어 들일 명령어의 주소**를 저장한다.
- 명령어 포인터(IP; Instruction Pointer)라고 부르는 CPU도 있다.

### 명령어 레지스터

- IR; Instruction Register
- 해석할 명령어, 즉 방금 **메모리에서 읽어 들인 명령어**를 저장하는 레지스터
- **제어장치**는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

### 메모리 주소 레지스터

- MAR; Memory Address Register
- **메모리의 주소**를 저장하는 레지스터
- CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

### 메모리 버퍼 레지스터

- MBR; Memory Buffer Register
- **메모리와 주고받을 값(데이터와 명령어)**을 저장하는 레지스터
- CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다.

### 예시

[[컴퓨터 공학 기초 강의] 10강. CPU의 내부 구성 - 레지스터](https://youtu.be/fSCHizcezTs?si=uda-9nG4dXwxN4_0&t=303)

메모리에 저장된 프로그램을 실행하는 과정에서 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터에 어떤 값들이 담기는지 알아보자.

1. CPU로 실행한 프로그램이 1000번지부터 1500번지부터 저장되어 있다고 가정
2. 프로그램을 처음부터 실행하기 위해 **프로그램 카운터**에 1000이 저장 → 메모리에서 가져올 명령어가 1000번지에 있다는 것을 의미
3. 1000번지를 읽어 들이기 위해서 주소 버스로 1000번지를 내보내야 한다. 이를 위해 **메모리 주소 레지스터**에 1000이 저장됨
4. ‘메모리 읽기’ **제어 신호와 메모리 주소 레지스터 값**이 각각 제어 버스와 주소 버스를 통해 메모리에 보내진다.
5. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 **메모리 버퍼 레지스터로 전달됨**
    1. **프로그램 카운터**는 증가되어 다음 명령어를 읽어 들일 준비를 함
    2. **메모리 주소 레지스터**는 리셋됨
6. 메모리 버퍼 레지스터에 저장된 값은 **명령어 레지스터**로 이동
7. **제어장치**는 **명령어 레지스터**의 명령어를 해석하고 제어 신호를 발생

위와 같이 **프로그램 카운터**는 지속적으로 증가하며 계속해서 다음 명령어를 읽어 들일 준비를 한다. 이 과정이 반복되면서 CPU는 프로그램을 차례대로 실행해 나간다.

### 범용 레지스터

- general purpose register
- 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
- 데이터와 주소를 모두 저장할 수 있다.
- 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 가지고 있다.’

### 플래그 레지스터

- flag register
- 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

## 특정 레지스터를 이용한 주소 지정 방식(1) : 스택 주소 지정 방식

- `스택 주소 지정 방식`
    - 스택과 스택 포인터를 이용한 주소 지정 방식
- `스택 포인터`
    - 스택의 꼭대기를 가리키는 레지스터
    - 스택의 어디까지 데이터가 채워져 있는지에 대한 표시
- `스택 영역`
    - 메모리 안에 스택처럼 사용할 영역이 정해져 있다.
    - 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역이다.

![](https://velog.velcdn.com/images/ncookie/post/b617d252-4d44-4717-ab98-a47b25e38f17/image.png)

## 특정 레지스터를 이용한 주소 지정 방식(2) : 변위 주소 지정 방식

`변위 주소 지정 방식(displacement addressing mode)`이란 **오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식**이다. 

이 방식을 사용하는 명령어는 연산 코드 필드, 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드, 그리고 주소를 담고 있는 오퍼랜드 필드가 있다. 여기서 어떤 레지스터에 더하는지에 따라 `상대 주소 지정 방식`, `베이스 레지스터 주소 지정 방식` 등으로 나뉜다.

![](https://velog.velcdn.com/images/ncookie/post/7b8cf7a8-1ca1-4edf-a896-4e90ef3cbd0b/image.png)

### 상대 주소 지정 방식

- relative addressing mode
- 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
- 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌, **분기하여 특정 주소의 코드를 실행할 때 사용**된다.

![](https://velog.velcdn.com/images/ncookie/post/49a2d5e2-c934-4f53-bde1-032ee58ef1dc/image.png)

### 베이스 레지스터 주소 지정 방식

- base-register addressing mode
- 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
- 베이스 레지스터는 ‘기준 주소’, 오퍼랜드는 ‘기준 주소로부터 떨어진 거리’로서의 역할
    - **베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식**

![](https://velog.velcdn.com/images/ncookie/post/4a6701c1-15f5-4456-ae55-af53798c1fee/image.png)

---

# 명령어 사이클과 인터럽트

## 명령어 사이클

- `명령어 사이클(instruction cycle)` : 프로그램 속 각각의 명령어들이 반복되며 실행되는 일정한 주기

- `인출 사이클(fetch cycle)` : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- `실행 사이클(execution cycle)` : CPU로 가져온 명령어를 실행하는 단계
    - 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계

프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행된다. 하지만 일부 명령어는우 이 경우에 해당하지 않기도 한다. 간접 주소 지정 방식과 같이 _명령어를 실행하기 위해서는 메모리 접근을 한 번 더 해야 하기 때문_이다.이 단계를 `간접 사이클(indirect cycle)`이라고 한다.

![](https://velog.velcdn.com/images/ncookie/post/01478a7e-8e83-49ff-ae37-dd6e1e570f4e/image.png)

## 인터럽트

- `인터럽트(interrupt)` : CPU의 작업을 방해하는 신호
- `동기 인터럽트(synchronous interrupts)` : CPU에 의해 발생하는 인터럽트
    - CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때 발생
    - Ex) CPU가 실행하는 프로그래밍 상의 오류와 같은 예외적인 상황에 마주쳤을 때 등
    - `예외(exception)`라고도 부름
- `비동기 인터럽트(asynchronous interrupts)` : 주로 입출력장치에 의해 발생하는 인터럽트
    - Ex) 프린터와 같은 입출력장치에서 작업을 끝낸 후 CPU에 완료 알림을 보냄 / 키보드, 마우스와 같은 입출력장치에서 CPU에 입력 알림을 보냄
    - 일반적으로 부르는 인터럽트가 여기에 해당함
    - 여기서는 용어의 혼동을 방지하기 위해 `하드웨어 인터럽트`라고 부름

### 하드웨어 인터럽트

CPU가 프린터에 출력 명령을 보냈다고 했을 때, 인터럽트를 사용하지 않으면 주기적으로 프린터의 완료 여부를 확인해야 한다. 이로 인해 CPU는 다른 작업을 처리할 수 없으므로 CPU 사이클 낭비이다. 

인터럽트를 사용한다면 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다. _하드웨어 인터럽트는 입출력 장업 중에도 CPU로 하여금 효율적으로 명령어를 처리할 수 있게 한다._

### 하드웨어 인터럽트 처리 순서

CPU가 인터럽트를 처리하는 방식은 종류를 막론하고 대동소이하다.

1. 입출력장치는 CPU에 `인터럽트 요청 신호`를 보낸다.
2. CPU는 실행 사이클이 끝나고 _명령어를 인출하기 전 항상 인터럽트 여부를 확인_한다.
3. CPU는 인터럽트 요청을 확인하고 _`인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인_한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 _지금까지의 작업을 백업_한다.
5. CPU는 _`인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행_한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 (4)에서 _백업해 둔 작업을 복구하여 실행을 재개_한다.

- `인터럽트 요청 신호` : 지금 인터럽트를 할 수 있는지 보내는 신호
- `인터럽트 플래그(interrupt flag)` : 플래그 레지스터에 저장되는, 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
    - 인터럽트 플래그가 불가능으로 설정되어 있더라도 무시할 수 없는 요청이 있음
    - Ex) 정전이나 하드웨어 고장과 같이 _반드시 가장 먼저 처리해야 하는 인터럽트_ 등
- `인터럽트 서비스 루틴(ISR; Interrupt Service Routine)`
    - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
    - `인터럽트 핸들러(interrupt handler)`라고도 부름
- 인터럽트 벡터(interrupt vecotr)
    - 인터럽트 서비스 루틴을 식별하기 위한 정보
    - 메모리에는 여러 개의 인터럽트 서비스 루틴이 저장되어 있음
    - _인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문_에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있음
    - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 _데이터 버스를 통해 인터럽트 벡터를 전달_받는다.

![](https://velog.velcdn.com/images/ncookie/post/62a37934-6eb1-4f39-a7e2-6bae95ecd76a/image.png)

> 1. 정상적으로 작업 진행
2. 인터럽트 발생
3. 인터럽트 서비스 루틴으로 점프
4. 인터럽트 서비스 루틴 실행
5. 기존 작업으로 점프
6. 기존 작업 수행 재개
> 

CPU가 인터럽트를 처리한다
→ _인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다. 인터럽트 서비스 루틴을 실행하기 위한 시작 주소는 인터럽트 벡터를 통해 알 수 있다._

인터럽트 서비스 루틴은 여느 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있다. 때문에 인터럽트 서비스 루틴도 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행된다.

CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 _현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업_한다. 그러고 나서 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴을 실행한다.

![](https://velog.velcdn.com/images/ncookie/post/3e9285d4-94f8-4281-a179-466e0f29dc87/image.png)

인터럽트 사이클까지 추가한 명령어 사이클은 아래와 같다. CPU는 이와 같은 과정을 반복해 나가며 프로그램을 실행한다.

![](https://velog.velcdn.com/images/ncookie/post/a5819899-9295-4c4d-bded-b5f5a50ced8a/image.png)

## 예외의 종류

`예외`가 발생하면 CPU는 하던 작업을 중단하고 해당 예외를 처리한다. 예외를 처리하고 나면 다시 본래 하던 작업으로 돌아와 실행을 재개한다. 여기서 CPU가 본래 하던 작업으로 되돌아 왔을 때 _예외가 발생한 명령어부터 실행_하느냐, _예외가 발생한 명령어의 다음 명령어부터 실행_하느냐에 따라 `폴트`와 `트랩`으로 나누어진다.

`폴트(falut)`는 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외이다. 

보조기억장치에 접근해야 하는 명령어를 실행한다고 할 때, CPU는 폴트를 발생시키고 보조기억장치로부터 필요한 데이터를 메모리로 가져와 저장한다. 이후 CPU는 폴트가 발생한 그 명령어부터 실행한다.

`트랩(trap)`은 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외이다. 주로 디버깅할 때 사용한다.

이 외로 CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외인 `중단(abort)`나, 시스템 호출이 발생했을 때 나타나는 `소프트웨어 인터럽트(software interrupt)` 등이 있다.

# 참고
- [혼자 공부하는 컴퓨터 구조+운영체제](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/)
- [유튜브 링크](https://www.youtube.com/playlist?list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl)

![](https://velog.velcdn.com/images/ncookie/post/3e9f7fd5-bc60-48cb-9d56-5adf9e4594d9/image.png)
